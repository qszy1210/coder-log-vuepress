---
title: 2019-08-03-bitadd
date: 2019-08-03 15:17:34
tags: add bitadd
---

# 位运算实现加减法

```js
// 先定义位运算加法
function bitAdd(m, n){
    while(m){
        [m, n] = [(m & n) << 1, m ^ n];
    }
    return n;
}
```

解释一下, m & n 按位与, 只要有一个为0, 那么返回0, 否则返回1(即都是1的情况下)
m ^ n , 按位异或, 如果对应位数相同的话, 返回0, 不同的话, 返回 1

按照上边的, 如果按照二进制进行加法计算, 比如 0b1101 + 0b1011
如果两个位都是 1, 那么处理后的结果肯定是 0 (不考虑进位的情况);
如果两个位一个是0, 一个是1, 那么结果肯定是 1;
如果两个位都是0, 那么结果肯定是0;


## *方法理解:*

这个方法很好的实现了加法的含义:
对于二进制来说, 表示数据的只有1, 0是占位用的.
所以, 对于加法, 保存了1的信息(1的位置), 即表示了正确的数据.

两个数据相加, 相同的都是1的情况, 最后肯定是0(排除进位)
一个是1的情况, 最后结果是1
两个是0的情况, 最后结果是0
即 异或的含义;

与操作加左移位,
即进位的含义.

将加法解释为: **不考虑进位的加法 + 进位信息**

反复循环到没有进位, 即 m = 0, 为止.

## 详细过程解释:
m & n 进行与操作, 然后左移 1 位, 然后赋值给 m

如上, 了解下 m & n

> 第几位,都是从 0 开始计算的 ~~~

```js
(0b1101 & 0b1011).toString(2)  //"1001" 表示第0位和第3位要进位, 存储进位的情况
```
请首先执行以下的操作, 了解左移
```js
(0b1001<<1).toString(2) //"10010", 右边加0, 整体表现为左移一位
```

```js
(0b1101 ^ 0b1011).toString(2) // "110", 表示如果没有进位的情况的结果(最后一位的计算结果)
```

从头开始来
此时候 m, n 如下 0b1101 0b1011
(0b1101 & 0b1011).toString(2) // "1001", 左移一位为 10010
(0b1101 ^ 0b1011).toString(2) // "110"

此时候 m, n 如下 0b10010 0b110
(0b10010 & 0b110).toString(2) // "10", 左移一位为 100
(0b10010 ^ 0b110).toString(2) // "10100"

此时候 m, n 如下 0b100 0b10100
(0b100 & 0b10100).toString(2) // "100", 左移一位为 1000
(0b100 ^ 0b10100).toString(2) // "10000"

此时候 m, n 如下 0b1000 0b10000
(0b1000 & 0b10000).toString(2) // "0", 左移一位为 0
(0b1000 ^ 0b10000).toString(2) // "11000"